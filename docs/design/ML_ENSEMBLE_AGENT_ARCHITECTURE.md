# æ™ºæ…§èª¿åº¦ç­–ç•¥ï¼šå¾ ML Ensemble åˆ° Agent Orchestration

> è¶…è¶Šç¡¬é–¾å€¼ï¼Œæ¢ç´¢æ›´æ™ºæ…§çš„çµ„åˆæ–¹å¼

## ç¾ç‹€åˆ†æ

### ç›®å‰çš„èª¿åº¦æ–¹å¼ï¼šç¡¬é–¾å€¼

```python
if char_count < 30000:
    return 'flash'
elif char_count > 100000:
    return 'chunked + pro'
else:
    return 'pro'
```

### å•é¡Œï¼š

- å–®ä¸€ç¶­åº¦æ±ºç­–ï¼ˆå­—å…ƒæ•¸ï¼‰
- é‚Šç•ŒåƒµåŒ–ï¼ˆ29999 vs 30001 è™•ç†æ–¹å¼æˆªç„¶ä¸åŒï¼‰
- ç„¡æ³•å­¸ç¿’å’Œé©æ‡‰

---

## ML Ensemble æ–¹æ³•å°æ‡‰åˆ° Agent èª¿åº¦

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ML Ensemble â†’ Agent Orchestration                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   ML æ–¹æ³•       â”‚   Agent å°æ‡‰       â”‚   é©ç”¨å ´æ™¯                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Bagging       â”‚   Multi-Agent     â”‚   éœ€è¦å¤šè¦–è§’é©—è­‰               â”‚
â”‚                 â”‚   Voting          â”‚                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Boosting      â”‚   Cascade         â”‚   æ¼¸é€²å¼ç²¾ç…‰                   â”‚
â”‚                 â”‚   Refinement      â”‚                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Stacking      â”‚   Meta-Agent      â”‚   å­¸ç¿’æœ€ä½³çµ„åˆç­–ç•¥             â”‚
â”‚                 â”‚   Learner         â”‚                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   MoE           â”‚   Dynamic         â”‚   æ ¹æ“šè¼¸å…¥ç‰¹å¾µè·¯ç”±             â”‚
â”‚ (Mixture of     â”‚   Expert          â”‚                               â”‚
â”‚  Experts)       â”‚   Routing         â”‚                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ç­–ç•¥ 1ï¼šMulti-Agent Voting (é¡ä¼¼ Bagging)

### æ¦‚å¿µ

å¤šå€‹ Agent å„è‡ªç¨ç«‹åˆ†æï¼Œç„¶å¾ŒæŠ•ç¥¨æˆ–åŠ æ¬Šå¹³å‡ã€‚

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Multi-Agent Voting                        â”‚
â”‚                                                             â”‚
â”‚   è¼¸å…¥ â”€â”€â”¬â”€â”€â–º Agent A (Flash) â”€â”€â”€â–º çµæœ A â”€â”€â”              â”‚
â”‚          â”‚                                   â”‚              â”‚
â”‚          â”œâ”€â”€â–º Agent B (Pro) â”€â”€â”€â”€â”€â–º çµæœ B â”€â”€â”¼â”€â”€â–º æŠ•ç¥¨/     â”‚
â”‚          â”‚                                   â”‚    åŠ æ¬Š â”€â”€â–º æœ€çµ‚çµæœ
â”‚          â””â”€â”€â–º Agent C (Gemini) â”€â”€â–º çµæœ C â”€â”€â”˜              â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### å¯¦ä½œæ€è·¯

```python
class VotingOrchestrator:
    def __init__(self):
        self.agents = [
            {'name': 'flash', 'weight': 0.3, 'cost': 1},
            {'name': 'pro', 'weight': 0.5, 'cost': 5},
            {'name': 'gemini', 'weight': 0.2, 'cost': 3},
        ]

    def decide(self, input_text, budget='normal'):
        if budget == 'low':
            # åªç”¨ä¾¿å®œçš„
            selected = [a for a in self.agents if a['cost'] <= 2]
        elif budget == 'high':
            # å…¨éƒ¨éƒ½ç”¨ï¼ŒåŠ æ¬ŠæŠ•ç¥¨
            selected = self.agents
        else:
            # æŠ½æ¨£ 2 å€‹
            selected = random.sample(self.agents, 2)

        results = [self.call_agent(a, input_text) for a in selected]
        return self.weighted_merge(results, selected)
```

### é©ç”¨å ´æ™¯

- é«˜é¢¨éšªæ±ºç­–ï¼ˆéœ€è¦å¤šé‡é©—è­‰ï¼‰
- çµæœå¯é‡åŒ–æ¯”è¼ƒï¼ˆå¦‚åˆ†é¡ã€è©•åˆ†ï¼‰
- å¯å®¹å¿è¼ƒé«˜å»¶é²/æˆæœ¬

---

## ç­–ç•¥ 2ï¼šCascade Refinement (é¡ä¼¼ Boosting)

### æ¦‚å¿µ

åºåˆ—åŒ–è™•ç†ï¼šå…ˆç”¨å¿«é€Ÿæ¨¡å‹ï¼Œæ ¹æ“šä¿¡å¿ƒåº¦æ±ºå®šæ˜¯å¦å‡ç´šã€‚

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Cascade Refinement                        â”‚
â”‚                                                             â”‚
â”‚   è¼¸å…¥ â”€â”€â–º Flash â”€â”€â”¬â”€â”€ é«˜ä¿¡å¿ƒ (>0.8) â”€â”€â–º ç›´æ¥è¼¸å‡º           â”‚
â”‚                    â”‚                                        â”‚
â”‚                    â””â”€â”€ ä½ä¿¡å¿ƒ (<0.8) â”€â”€â–º Pro â”€â”€â”¬â”€â”€ é«˜ä¿¡å¿ƒ â”€â”€â–º è¼¸å‡º
â”‚                                                â”‚             â”‚
â”‚                                                â””â”€â”€ ä½ä¿¡å¿ƒ â”€â”€â–º äººå·¥
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### å¯¦ä½œæ€è·¯

```python
class CascadeOrchestrator:
    CONFIDENCE_THRESHOLD = 0.8

    def decide(self, input_text):
        # Stage 1: å¿«é€Ÿæ¨¡å‹
        result_1, confidence_1 = self.call_with_confidence('flash', input_text)

        if confidence_1 >= self.CONFIDENCE_THRESHOLD:
            return result_1  # å¿«é€Ÿè¿”å›

        # Stage 2: å‡ç´šåˆ°æ›´å¼·æ¨¡å‹
        result_2, confidence_2 = self.call_with_confidence('pro', input_text)

        if confidence_2 >= self.CONFIDENCE_THRESHOLD:
            return result_2

        # Stage 3: äººæ©Ÿå”ä½œ
        return self.request_human_review(result_2)

    def call_with_confidence(self, model, text):
        # è®“æ¨¡å‹åŒæ™‚è¼¸å‡ºçµæœå’Œè‡ªè©•ä¿¡å¿ƒåº¦
        prompt = f"""
        è«‹åˆ†æä»¥ä¸‹å…§å®¹ï¼Œä¸¦çµ¦å‡ºï¼š
        1. ä½ çš„åˆ†æçµæœ
        2. ä½ å°é€™å€‹çµæœçš„ä¿¡å¿ƒåº¦ (0-1)

        {text}
        """
        response = call_model(model, prompt)
        return parse_result_and_confidence(response)
```

### é©ç”¨å ´æ™¯

- å¤§éƒ¨åˆ†è¼¸å…¥å¯ä»¥ç”¨ç°¡å–®æ¨¡å‹è™•ç†
- éœ€è¦æ§åˆ¶æˆæœ¬ä½†ä¸çŠ§ç‰²å“è³ª
- æœ‰æ˜ç¢ºçš„ã€Œä¿¡å¿ƒåº¦ã€æŒ‡æ¨™

**å¯¦ä½œä½ç½®**: `grasshopper_mcp/langgraph/core/confidence.py`

---

## ç­–ç•¥ 3ï¼šMeta-Agent Learner (é¡ä¼¼ Stacking)

### æ¦‚å¿µ

ç”¨ä¸€å€‹ Meta-Agent å­¸ç¿’ã€Œä»€éº¼æƒ…æ³è©²ç”¨ä»€éº¼ç­–ç•¥ã€ã€‚

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Meta-Agent Stacking                       â”‚
â”‚                                                             â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                         â”‚
â”‚   è¼¸å…¥ç‰¹å¾µ â”€â”€â”€â”€â”€â”€â–º â”‚ Meta-Agent  â”‚ â”€â”€â–º é¸æ“‡ç­–ç•¥            â”‚
â”‚   - å­—å…ƒæ•¸         â”‚ (å­¸ç¿’è·¯ç”±)  â”‚                         â”‚
â”‚   - æ„åœ–é¡å‹       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                         â”‚
â”‚   - éŒ¯èª¤å¯†åº¦              â”‚                                â”‚
â”‚   - å°ˆæ¡ˆèªè¨€              â–¼                                â”‚
â”‚   - æ­·å²æˆåŠŸç‡     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚                    â”‚  åŸ·è¡Œé¸å®šçš„ç­–ç•¥     â”‚                 â”‚
â”‚                    â”‚  - flash_direct     â”‚                 â”‚
â”‚                    â”‚  - pro_direct       â”‚                 â”‚
â”‚                    â”‚  - chunked_pro      â”‚                 â”‚
â”‚                    â”‚  - voting           â”‚                 â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â”‚                             â”‚                              â”‚
â”‚                             â–¼                              â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚                    â”‚    å›é¥‹å­¸ç¿’         â”‚                 â”‚
â”‚                    â”‚  (æˆåŠŸ/å¤±æ•—/è©•åˆ†)   â”‚                 â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### å¯¦ä½œæ€è·¯

```python
class MetaAgentLearner:
    def __init__(self):
        # ç°¡å–®çš„è¦å‰‡åº«ï¼ˆå¯é€æ­¥å­¸ç¿’å„ªåŒ–ï¼‰
        self.decision_log = []
        self.success_rates = defaultdict(lambda: {'success': 0, 'total': 0})

    def extract_features(self, text, context):
        return {
            'char_count': len(text),
            'intent': self.classify_intent(text),
            'error_density': self.calc_error_density(text),
            'language': context.get('language', 'unknown'),
            'time_of_day': datetime.now().hour,
            'project_history': self.get_project_success_rate(context['project']),
        }

    def decide(self, text, context):
        features = self.extract_features(text, context)

        # æŸ¥è©¢æ­·å²ï¼šé¡ä¼¼æƒ…æ³ä¸‹ä»€éº¼ç­–ç•¥æœ€æˆåŠŸï¼Ÿ
        similar_cases = self.find_similar_cases(features)

        if similar_cases:
            best_strategy = max(similar_cases, key=lambda x: x['success_rate'])
            return best_strategy['strategy']

        # ç„¡æ­·å²ï¼šç”¨è¦å‰‡ fallback
        return self.rule_based_decision(features)

    def record_outcome(self, features, strategy, success, score):
        """å›é¥‹å­¸ç¿’ï¼šè¨˜éŒ„é€™æ¬¡æ±ºç­–çš„çµæœ"""
        self.decision_log.append({
            'features': features,
            'strategy': strategy,
            'success': success,
            'score': score,
            'timestamp': datetime.now()
        })
        self.success_rates[strategy]['total'] += 1
        if success:
            self.success_rates[strategy]['success'] += 1
```

### é©ç”¨å ´æ™¯

- æœ‰è¶³å¤ çš„æ­·å²æ•¸æ“šå¯å­¸ç¿’
- æ±ºç­–ç¶­åº¦å¤šï¼Œé›£ä»¥æ‰‹å‹•èª¿åƒ
- éœ€è¦æŒçºŒå„ªåŒ–çš„é•·æœŸç³»çµ±

---

## ç­–ç•¥ 4ï¼šDynamic Expert Routing (é¡ä¼¼ MoE)

### æ¦‚å¿µ

é¡ä¼¼ Mixture of Expertsï¼Œç”¨è¼•é‡ Router å‹•æ…‹é¸æ“‡å°ˆå®¶ã€‚

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Dynamic Expert Routing                     â”‚
â”‚                                                             â”‚
â”‚                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                          â”‚
â”‚   è¼¸å…¥ â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚ Lightweight  â”‚                          â”‚
â”‚                  â”‚   Router     â”‚                          â”‚
â”‚                  â”‚ (è¦å‰‡/å°æ¨¡å‹)â”‚                          â”‚
â”‚                  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                          â”‚
â”‚                         â”‚                                   â”‚
â”‚          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚          â–¼              â–¼              â–¼                   â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚   â”‚   Debug    â”‚ â”‚  Feature   â”‚ â”‚  Explain   â”‚            â”‚
â”‚   â”‚   Expert   â”‚ â”‚   Expert   â”‚ â”‚   Expert   â”‚            â”‚
â”‚   â”‚            â”‚ â”‚            â”‚ â”‚            â”‚            â”‚
â”‚   â”‚ - ä½æº«åº¦   â”‚ â”‚ - é«˜æº«åº¦   â”‚ â”‚ - æ•™å­¸é¢¨æ ¼ â”‚            â”‚
â”‚   â”‚ - é—œæ³¨éŒ¯èª¤ â”‚ â”‚ - å‰µæ„å°å‘ â”‚ â”‚ - ç¯„ä¾‹è±å¯Œ â”‚            â”‚
â”‚   â”‚ - Proæ¨¡å‹  â”‚ â”‚ - Flashæ¨¡å‹â”‚ â”‚ - ä¸­ç­‰æ¨¡å‹ â”‚            â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### å¯¦ä½œæ€è·¯

```yaml
# experts.yaml
experts:
  debug_expert:
    model: "gemini-1.5-pro"
    temperature: 0.2
    system_prompt: |
      ä½ æ˜¯è³‡æ·±é™¤éŒ¯å°ˆå®¶ã€‚å°ˆæ³¨æ–¼ï¼š
      - Error Stack Trace åˆ†æ
      - Root Cause è¿½è¹¤
      - ä¿®å¾©é©—è­‰

  feature_expert:
    model: "gemini-2.0-flash"
    temperature: 0.8
    system_prompt: |
      ä½ æ˜¯å‰µæ„é–‹ç™¼å¤¥ä¼´ã€‚å°ˆæ³¨æ–¼ï¼š
      - æ¶æ§‹è¨­è¨ˆ
      - æœ€ä½³å¯¦è¸
      - å¯æ“´å±•æ€§

  explain_expert:
    model: "gemini-1.5-flash"
    temperature: 0.5
    system_prompt: |
      ä½ æ˜¯æŠ€è¡“æ•™è‚²è€…ã€‚å°ˆæ³¨æ–¼ï¼š
      - æ¦‚å¿µè§£é‡‹
      - ç¨‹å¼ç¢¼ç¯„ä¾‹
      - é¡æ¯”èªªæ˜

routing_rules:
  - condition: {intent: DEBUG, error_density: ">0.5"}
    expert: debug_expert

  - condition: {intent: FEATURE, char_count: "<20000"}
    expert: feature_expert

  - condition: {intent: EXPLAIN}
    expert: explain_expert
```

### é©ç”¨å ´æ™¯

- ä»»å‹™é¡å‹æ˜ç¢ºå¯åˆ†
- ä¸åŒé¡å‹éœ€è¦ä¸åŒã€Œå°ˆå®¶ç‰¹è³ªã€
- å°ˆå®¶å¯ç¨ç«‹å„ªåŒ–

**å¯¦ä½œä½ç½®**: `grasshopper_mcp/langgraph/core/routing.py`

---

## ç­–ç•¥ 5ï¼šSpeculative Execution (æŠ•æ©ŸåŸ·è¡Œ)

### æ¦‚å¿µ

ä¸¦è¡ŒåŸ·è¡Œå¤šå€‹ç­–ç•¥ï¼Œé¸æ“‡æœ€å¥½çš„çµæœï¼ˆæˆ–æœ€å¿«å®Œæˆçš„ï¼‰ã€‚

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Speculative Execution                      â”‚
â”‚                                                             â”‚
â”‚   è¼¸å…¥ â”€â”€â”¬â”€â”€â–º Flash (ä¸¦è¡Œ) â”€â”€â–º çµæœ A â”€â”€â”                  â”‚
â”‚          â”‚                               â”‚                  â”‚
â”‚          â”œâ”€â”€â–º Pro (ä¸¦è¡Œ) â”€â”€â”€â”€â–º çµæœ B â”€â”€â”¼â”€â”€â–º è©•ä¼°å™¨ â”€â”€â–º æœ€ä½³çµæœ
â”‚          â”‚                               â”‚                  â”‚
â”‚          â””â”€â”€â–º Gemini (ä¸¦è¡Œ) â”€â–º çµæœ C â”€â”€â”˜                  â”‚
â”‚                                                             â”‚
â”‚   ç­–ç•¥ï¼š                                                    â”‚
â”‚   - Race: æœ€å¿«å®Œæˆçš„ç²å‹                                    â”‚
â”‚   - Quality: è©•åˆ†æœ€é«˜çš„ç²å‹                                 â”‚
â”‚   - Hybrid: åœ¨æ™‚é–“é™åˆ¶å…§é¸æœ€å¥½çš„                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### å¯¦ä½œæ€è·¯

```python
import asyncio

class SpeculativeExecutor:
    async def execute_with_race(self, input_text, timeout=5.0):
        """Race æ¨¡å¼ï¼šæœ€å¿«å®Œæˆçš„ç²å‹"""
        tasks = [
            self.call_agent_async('flash', input_text),
            self.call_agent_async('pro', input_text),
        ]

        done, pending = await asyncio.wait(
            tasks,
            timeout=timeout,
            return_when=asyncio.FIRST_COMPLETED
        )

        # å–æ¶ˆæœªå®Œæˆçš„ä»»å‹™
        for task in pending:
            task.cancel()

        return done.pop().result()

    async def execute_with_quality(self, input_text, timeout=10.0):
        """Quality æ¨¡å¼ï¼šè©•åˆ†æœ€é«˜çš„ç²å‹"""
        tasks = [
            self.call_agent_async('flash', input_text),
            self.call_agent_async('pro', input_text),
        ]

        done, pending = await asyncio.wait(tasks, timeout=timeout)

        results = [task.result() for task in done]
        scores = [self.evaluate_quality(r) for r in results]

        best_idx = scores.index(max(scores))
        return results[best_idx]
```

### é©ç”¨å ´æ™¯

- ä½å»¶é²è¦æ±‚ï¼ˆRace æ¨¡å¼ï¼‰
- é«˜å“è³ªè¦æ±‚ä¸”é ç®—å……è¶³ï¼ˆQuality æ¨¡å¼ï¼‰
- ä¸ç¢ºå®šå“ªå€‹ç­–ç•¥æ›´å¥½ï¼ˆæ¢ç´¢éšæ®µï¼‰

---

## ç­–ç•¥ 6ï¼šAdaptive Budget Allocation (è‡ªé©æ‡‰é ç®—)

### æ¦‚å¿µ

æ ¹æ“šä»»å‹™ã€Œåƒ¹å€¼ã€å‹•æ…‹åˆ†é…è¨ˆç®—é ç®—ã€‚

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               Adaptive Budget Allocation                    â”‚
â”‚                                                             â”‚
â”‚   è¼¸å…¥ â”€â”€â–º åƒ¹å€¼è©•ä¼°å™¨ â”€â”€â”¬â”€â”€ é«˜åƒ¹å€¼ â”€â”€â–º é«˜é ç®— (Pro + é©—è­‰)  â”‚
â”‚                         â”‚                                   â”‚
â”‚                         â”œâ”€â”€ ä¸­åƒ¹å€¼ â”€â”€â–º ä¸­é ç®— (Pro)         â”‚
â”‚                         â”‚                                   â”‚
â”‚                         â””â”€â”€ ä½åƒ¹å€¼ â”€â”€â–º ä½é ç®— (Flash)       â”‚
â”‚                                                             â”‚
â”‚   åƒ¹å€¼å› ç´ ï¼š                                                â”‚
â”‚   - å°ˆæ¡ˆé‡è¦æ€§ï¼ˆç”Ÿç”¢ vs å¯¦é©—ï¼‰                              â”‚
â”‚   - ä»»å‹™é¡å‹ï¼ˆä¿® bug vs å¯«æ–‡æª”ï¼‰                            â”‚
â”‚   - ç”¨æˆ¶ç­‰ç´šï¼ˆä»˜è²» vs å…è²»ï¼‰                                â”‚
â”‚   - æ™‚é–“æ•æ„Ÿåº¦ï¼ˆç·Šæ€¥ vs ä¸€èˆ¬ï¼‰                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### å¯¦ä½œæ€è·¯

```python
class AdaptiveBudgetAllocator:
    def calculate_value(self, context):
        score = 0

        # å°ˆæ¡ˆé‡è¦æ€§
        if context.get('env') == 'production':
            score += 3
        elif context.get('env') == 'staging':
            score += 2

        # ä»»å‹™é¡å‹
        if context.get('intent') == 'DEBUG':
            score += 2  # Debug é€šå¸¸æ›´é‡è¦

        # ç”¨æˆ¶ç­‰ç´š
        if context.get('user_tier') == 'premium':
            score += 2

        # æ™‚é–“æ•æ„Ÿåº¦
        if context.get('urgent'):
            score += 1

        return score

    def allocate_budget(self, context):
        value = self.calculate_value(context)

        if value >= 6:
            return {
                'model': 'pro',
                'retry_limit': 3,
                'enable_verification': True,
                'timeout': 60
            }
        elif value >= 3:
            return {
                'model': 'pro',
                'retry_limit': 1,
                'enable_verification': False,
                'timeout': 30
            }
        else:
            return {
                'model': 'flash',
                'retry_limit': 1,
                'enable_verification': False,
                'timeout': 10
            }
```

---

## çµ„åˆç­–ç•¥ï¼šHybrid Pipeline

### æ¦‚å¿µ

çµåˆå¤šç¨®ç­–ç•¥ï¼Œå½¢æˆå®Œæ•´çš„æ™ºæ…§èª¿åº¦ç³»çµ±ã€‚

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        Hybrid Pipeline                              â”‚
â”‚                                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚   Stage 1   â”‚    â”‚   Stage 2   â”‚    â”‚   Stage 3   â”‚             â”‚
â”‚  â”‚   Feature   â”‚ â”€â–º â”‚   Router    â”‚ â”€â–º â”‚  Execution  â”‚             â”‚
â”‚  â”‚  Extraction â”‚    â”‚  (MoE-like) â”‚    â”‚  (Cascade)  â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚        â”‚                  â”‚                  â”‚                      â”‚
â”‚        â–¼                  â–¼                  â–¼                      â”‚
â”‚   IntentContext     Expert Selection    Confidence Check            â”‚
â”‚   + Value Score     + Budget Alloc      + Fallback                  â”‚
â”‚                                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                     Feedback Loop                             â”‚  â”‚
â”‚  â”‚   çµæœè©•åˆ† â†’ æ›´æ–°è·¯ç”±æ¬Šé‡ â†’ èª¿æ•´é ç®—åˆ†é… â†’ å„ªåŒ–å°ˆå®¶é¸æ“‡      â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### å¯¦ä½œæ¡†æ¶

```python
class HybridOrchestrator:
    def __init__(self):
        self.feature_extractor = IntentAnalyzer()
        self.value_estimator = AdaptiveBudgetAllocator()
        self.router = DynamicExpertRouter()
        self.cascade = CascadeOrchestrator()
        self.feedback_store = FeedbackStore()

    def process(self, input_text, context):
        # Stage 1: ç‰¹å¾µæå–
        features = self.feature_extractor.analyze(input_text)
        value = self.value_estimator.calculate_value(context)

        # Stage 2: è·¯ç”±æ±ºç­–ï¼ˆè€ƒæ…®æ­·å²åé¥‹ï¼‰
        historical_performance = self.feedback_store.get_performance(features)
        expert, budget = self.router.select(features, value, historical_performance)

        # Stage 3: åŸ·è¡Œï¼ˆå¸¶ Cascade fallbackï¼‰
        result, confidence = self.cascade.execute(
            input_text,
            expert=expert,
            budget=budget
        )

        # Feedback: è¨˜éŒ„çµæœ
        self.feedback_store.record(features, expert, result, confidence)

        return result
```

---

## å„ç­–ç•¥æ¯”è¼ƒ

| ç­–ç•¥ | å»¶é² | æˆæœ¬ | å“è³ª | å¯¦ä½œè¤‡é›œåº¦ | é©ç”¨æ¨£æœ¬é‡ |
|------|------|------|------|------------|------------|
| Voting (Bagging) | é«˜ | é«˜ | é«˜ | ä¸­ | ä»»æ„ |
| Cascade (Boosting) | ä½~ä¸­ | ä½~ä¸­ | ä¸­~é«˜ | ä¸­ | ä»»æ„ |
| Meta-Learner (Stacking) | ä½ | ä½ | æŒçºŒå„ªåŒ– | é«˜ | 100+ |
| Expert Routing (MoE) | ä½ | ä½ | é«˜ | ä¸­ | ä»»æ„ |
| Speculative | ä½ | é«˜ | é«˜ | ä¸­ | ä»»æ„ |
| Adaptive Budget | ä½ | å‹•æ…‹ | å‹•æ…‹ | ä½ | ä»»æ„ |

---

## å»ºè­°çš„æ¼”é€²è·¯å¾‘

```
ç›®å‰ (v2.1)              çŸ­æœŸ                    ä¸­æœŸ                   é•·æœŸ
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ç¡¬é–¾å€¼   â”‚   â”€â”€â–º   â”‚ Cascade  â”‚   â”€â”€â–º    â”‚ Expert   â”‚   â”€â”€â–º   â”‚ Hybrid   â”‚
â”‚ + æ„åœ–   â”‚         â”‚ + ä¿¡å¿ƒåº¦ â”‚          â”‚ Routing  â”‚         â”‚ Pipeline â”‚
â”‚          â”‚         â”‚          â”‚          â”‚ + åé¥‹   â”‚         â”‚ + å­¸ç¿’   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚                     â”‚                     â”‚                    â”‚
    â–¼                     â–¼                     â–¼                    â–¼
 39 æ¨£æœ¬              39 æ¨£æœ¬               100+ æ¨£æœ¬           500+ æ¨£æœ¬
 é›¶é¡å¤–æˆæœ¬           ä½é¡å¤–æˆæœ¬            ä¸­ç­‰æˆæœ¬             æŒçºŒå„ªåŒ–
```

### çŸ­æœŸå»ºè­°ï¼šåŠ å…¥ Cascade + Confidence

æœ€å°æ”¹å‹•ï¼Œæœ€å¤§æ”¶ç›Šï¼š

```python
# åœ¨ç¾æœ‰ v2.1 åŸºç¤ä¸Šï¼ŒåŠ å…¥ä¿¡å¿ƒåº¦æª¢æŸ¥
def analyze_and_decide(self, text, context):
    # ... ç¾æœ‰ Stage 1-3 ...

    # Stage 4: Cascade Execution
    result, confidence = self.execute_with_confidence(prompt, model)

    if confidence < 0.7 and model == 'flash':
        # å‡ç´šé‡è©¦
        result, confidence = self.execute_with_confidence(prompt, 'pro')

    return result
```

---

## ç¸½çµ

| å•é¡Œ | è§£æ³•éˆæ„Ÿ | æ ¸å¿ƒæ€æƒ³ |
|------|----------|----------|
| å–®ä¸€ç¶­åº¦æ±ºç­– | MoEã€Stacking | å¤šç¶­åº¦ç‰¹å¾µ â†’ å‹•æ…‹è·¯ç”± |
| é‚Šç•ŒåƒµåŒ– | Cascadeã€Boosting | ä¿¡å¿ƒåº¦é©…å‹• â†’ æ¼¸é€²å‡ç´š |
| ç„¡æ³•å­¸ç¿’ | Meta-Learnerã€Feedback Loop | è¨˜éŒ„çµæœ â†’ æŒçºŒå„ªåŒ– |
| æˆæœ¬å›ºå®š | Adaptive Budget | åƒ¹å€¼è©•ä¼° â†’ å‹•æ…‹åˆ†é… |
| å“è³ªä¸ç©©å®š | Votingã€Speculative | å¤šè·¯ä¸¦è¡Œ â†’ é¸æœ€ä½³ |

> ğŸ’¡ **æ ¸å¿ƒæ´å¯Ÿ**ï¼šå¾ã€Œç¡¬ç·¨ç¢¼è¦å‰‡ã€é€²åŒ–åˆ°ã€Œæ•¸æ“šé©…å‹•æ±ºç­–ã€ï¼Œé—œéµæ˜¯å»ºç«‹ **åé¥‹è¿´è·¯**ï¼Œè®“ç³»çµ±èƒ½å¾æ¯æ¬¡åŸ·è¡Œä¸­å­¸ç¿’ã€‚

---

## å¯¦ä½œç‹€æ…‹

| ç­–ç•¥ | ç‹€æ…‹ | æª”æ¡ˆ |
|------|------|------|
| MoE (Expert Routing) | âœ… å·²å¯¦ä½œ | `grasshopper_mcp/langgraph/core/routing.py` |
| Boosting (Cascade) | âœ… å·²å¯¦ä½œ | `grasshopper_mcp/langgraph/core/confidence.py` |
| Bagging (Voting) | â³ è¦åŠƒä¸­ | - |
| Stacking (Meta-Agent) | â³ è¦åŠƒä¸­ | - |
| Speculative Execution | â³ è¦åŠƒä¸­ | - |
| Adaptive Budget | â³ è¦åŠƒä¸­ | - |
| Hybrid Pipeline | â³ è¦åŠƒä¸­ | - |

---

*æœ€å¾Œæ›´æ–°: 2026-01-09*
